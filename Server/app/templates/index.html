{% extends "base.html" %}

{% load static %}

{% block content %}
<div class="container-fluid h-100">
    <div class="row justify-content-center h-100">
        <div class="col-8 h-100 p-0 ">
            <div class="card h-100 border-0 rounded-0">
                <div class="card-header rounded-0" style="background-color: #4c4c4c;">
                    <h4 class="card-title text-center" id="Titre">--------------</h4>
                </div>
                <div class="card-body d-flex flex-column p-0">

                    <div id="myDiagramDiv"></div>

                    <div id="botton_option" class="card text-dark bg-light d-flex flex-row overlay p-1"
                        style="height: 20%;width: 100%;">
                        <div class="d-flex  flex-column justify-content-between" style="flex: 1;">
                            <table class="h-100">
                                <tbody>
                                    <tr>
                                        <th scope="row">Graph Type</th>
                                        <td>
                                            <select name="graph_type" id="graph_type" onchange="_changeGraphType()"> >
                                                <option value="random">Random</option>
                                                <option value="cycle">Cycle</option>
                                                <option value="bipartite">Bipartite</option>
                                                <option value="grid">Grid</option>
                                                <option value="tree">Tree</option>
                                                <option value="star">Star</option>
                                                <option value="complete">Complete</option>
                                                <option value="path">Path</option>
                                                <option value="regular">Regular</option>
                                                <option value="planaire">Planaire</option>
                                                <option value="eulerien">Eulerien</option>
                                                <option value="hamiltonien">Hamiltonien</option>
                                                <option value="custom">Custom</option>
                                            </select>
                                        </td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Number of nodes</th>
                                        <td>
                                            <input type="number" name="nb_nodes" id="nb_nodes" value="10">
                                        </td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Layout</th>
                                        <td>
                                            <select name="layout" id="layout" onchange="_changeLayout()">
                                                <option value="layout">Default</option>
                                                <option value="force">Force</option>
                                                <option value="circular">Circular</option>
                                                <option value="layered">Layered</option>
                                                <option value="grid">Grid</option>
                                                <option value="tree">Tree</option>
                                            </select>
                                        </td>
                                    </tr>
                                </tbody>

                            </table>
                            <button class="btn btn-primary" onclick="_generateGraph()">Generate Graph</button>
                        </div>

                        <div id="blur_box" class="d-none"></div>
                    </div>

                </div>
            </div>
        </div>
        <div class="col-4 h-100 p-0 ">
            <div class="card h-100 border-0 rounded-0" style="background-color: #4c4c4c;">
                <div class="card-body d-flex flex-column h-100">
                    <div class="card">
                        <div class="card-header text-dark text-center">
                            MODE
                        </div>
                        <div class="card-body d-flex p-0 m-0 flex-column">

                            <select name="modes" id="mode-select" onchange="_changeMode()">
                                <option value="alice_bob">ALice-Bob</option>
                                <option value="alice_n_bob">Alice-N-Bob</option>
                                <option value="alice_mnist">Alice-NNIST</option>
                                <option value="mis">MIS</option>
                            </select>
                        </div>
                    </div>
                    <div id="box_alice_bob" class="d-flex flex-column  box_options h-100 d-none">
                        <div class="card d-flex " style="background-color: rgba(255, 255, 255, 0.616);">
                            <div class="card-header text-dark text-center">
                                Options
                            </div>
                            <div class="card-body d-flex p-0 m-0 flex-column">
                                <table class="table">

                                    <tbody class="h-100">


                                        <tr>
                                            <th scope="row">Ratio 1 Bob</th>
                                            <td>
                                                <input type="number" name="ratio_bob" id="ratio_bob" value="0.5">
                                            </td>
                                        </tr>
                                        <tr>
                                            <th scope="row">Ratio 1 Alice</th>
                                            <td>
                                                <input type="number" name="ratio_alice" id="ratio_alice" value="0.2">
                                            </td>
                                        </tr>
                                        <tr>
                                            <th scope="row">Message length</th>
                                            <td>
                                                <input type="number" name="message_length" id="message_length"
                                                    value="100">
                                            </td>
                                        </tr>
                                        <tr>
                                            <th scope="row">disconnect_percentage</th>
                                            <td>
                                                <input type="number" name="disconnect_percentage"
                                                    id="disconnect_percentage" value="20">

                                            </td>
                                        </tr>

                                    </tbody>
                                </table>
                                <button type="button" id="alice_bob_btn" onclick="simulate_alice_bob()"
                                    class="btn btn-success m-1">Start</button>
                            </div>
                        </div>
                        <div class=" d-flex p-1 flex-column" style="flex: 1;">
                            <table class="table" style="flex: 1;">
                                <thead>

                                    <tr>
                                        <td width="20%">Step</td>
                                        <td width="20%" class="text-center">Alice</td>
                                        <td width="20%" class="text-center">Bob</td>
                                        <td width="20%" class="text-center">Guess</td>
                                    </tr>
                                </thead>

                            </table>
                            <textarea id="console_alice_bob_alice" class="console" style="height: 100%;width: 100%;"
                                readonly></textarea>
                        </div>
                    </div>
                    <div id="box_alice_n_bob" class="flex-column  box_options h-100 d-none">
                        <div class="card d-flex " style="background-color: rgba(255, 255, 255, 0.616);">
                            <div class="card-header text-dark text-center">
                                Options
                            </div>
                            <div class="card-body d-flex p-0 m-0 flex-column">
                                <table class="table">

                                    <tbody class="h-100">
                                        <tr>
                                            <th scope="row">Ratio 1 Bob</th>
                                            <td>
                                                <input type="number" name="ratio_bob_n" id="ratio_bob_n" value="0.5">
                                            </td>
                                        </tr>
                                        <tr>
                                            <th scope="row">Ratio 1 Alice</th>
                                            <td>
                                                <input type="number" name="ratio_alice_n" id="ratio_alice_n"
                                                    value="0.2">
                                            </td>
                                        </tr>

                                        <tr>
                                            <th scope="row">Message length</th>
                                            <td>
                                                <input type="number" name="message_length_n" id="message_length_n"
                                                    value="10">
                                            </td>
                                        </tr>
                                        <tr>
                                            <th scope="row">disconnect_percentage</th>
                                            <td>
                                                <input type="number" name="disconnect_percentage_n"
                                                    id="disconnect_percentage_n" value="20">

                                            </td>
                                        </tr>



                                        <!-- <tr>
                                        <th scope="row">2</th>
                                        <td>Jacob</td>
                            
                                    </tr>
                                    <tr>
                                        <th scope="row">3</th>
                                        <td>Larry</td>
                                    
                                    </tr> -->
                                    </tbody>
                                </table>
                                <button id="alice_n_bob_btn" class="btn btn-success"
                                    onclick="simulate_alice_n_bob()">Run</button>
                            </div>
                        </div>
                        <div class=" d-flex p-1 flex-column" style="flex: 1;">
                            <div class="d-flex bg-dark" style="flex: 1;"></div>
                            <div class="d-flex bg-dark" style="flex: 1;"></div>
                        </div>
                    </div>
                    <div id="box_Mnist" class="box_options h-100 d-none flex-column">
                        <div class="card d-flex ">
                            <div class="card-header text-dark text-center">
                                Options
                            </div>
                            <div class="card-body d-flex p-0 m-0 flex-column">
                                <!-- table form  -->
                                <table class="table">

                                    <tbody class="h-100">

                                        <tr>
                                            <th scope="row">drop probability</th>
                                            <td>
                                                <input type="number" name="drop_probability" id="drop_probability"
                                                    value="0.6">
                                            </td>
                                        </tr>
                                        <tr>
                                            <th scope="row">Num samples</th>
                                            <td>
                                                <input type="number" name="num_samples" id="num_samples" value="10">
                                            </td>

                                        </tr>

                                    </tbody>
                                </table>
                                <button onclick="simulate_alice_mnist()" class="btn btn-success">Run</button>

                            </div>
                        </div>
                        <div class=" d-flex p-1 flex-column" style="flex: 1;">
                            <div class="d-flex bg-light" style="flex: 1;">
                                <div class=" card d-flex bg-transparent " style="flex: 1; ">
                                    <div class="card-header text-center text-dark">Original</div>
                                    <div id="img-original"
                                        style=" background-image: unset  ; background-size: contain; background-position: center; background-repeat: no-repeat; height: 100%; width: 100%;">
                                    </div>

                                </div>
                                <div class="card d-flex bg-transparent " style="flex: 1; ">
                                    <div class="card-header text-center text-dark">Restore</div>
                                    <div id="img-reconstructed"
                                        style=" background-image:unset  ; background-size: contain; background-position: center; background-repeat: no-repeat; height: 100%; width: 100%;">
                                    </div>
                                </div>
                            </div>
                            <div class=" d-flex bg-light  " style="flex: 1;">
                                <div class="card d-flex  bg-transparent text-dark " style="flex: 1;">
                                    <div class="card-header text-center">Noisy</div>
                                    <div id="img-dropped"
                                        style=" background-image: unset ; background-size: contain; background-position: center; background-repeat: no-repeat; height: 100%; width: 100%;">
                                    </div>

                                </div>
                                <div class="d-flex bg-dark " style="flex: 1; "></div>
                            </div>
                        </div>
                    </div>
                    <div id="box_mis" class="box_options h-100 d-none flex-column">
                        <div class="card d-flex ">
                            <div class="card-header text-dark text-center">
                                Options
                            </div>
                            <div class="card-body d-flex p-0 m-0 flex-column">
                                <!-- table form  -->
                                <table class="table">

                                    <tbody class="h-100">
                                        <tr>
                                            <th scope=" row">Most neighbord</th>
                                            <td>
                                                <input type="checkbox" name="most_neighbord"
                                                    id="start_node_with_most_neighbors" onclick="changeMisOption()"
                                                    value="1">
                                            </td>

                                        </tr>
                                    </tbody>
                                </table>
                                <button onclick="simulate_mis_once()" class="btn btn-success">Run</button>
                                <button onclick="mis_graph_coloration()" class="btn btn-primary">Color Graph</button>

                            </div>
                        </div>
                        <div class=" d-flex p-1 flex-column" style="flex: 1;">
                            <div class="d-flex bg-light" style="flex: 1;">
                                <div class=" card d-flex bg-transparent " style="flex: 1; ">
                                    <div class="card-header text-center text-dark">Result</div>
                                    <table class="table">
                                        <tbody>
                                            <tr>
                                                <td>Tours</td>
                                                <td id="tours_mis">0</td>
                                            </tr>
                                            <tr>
                                                <td>Nodes</td>
                                                <td id="mis_size">0</td>
                                            </tr>
                                            <tr>
                                                <td>Coloration</td>
                                                <td id="mis_coloration">0</td>
                                            </tr>


                                        </tbody>
                                    </table>



                                </div>

                            </div>
                        </div>
                    </div>
                </div>
                <div id="loader" style="display: none;">
                    <div
                        style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border: 1px solid #ccc; box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);color: black; ">
                        <p>Création des nœuds en cours...</p>
                        <progress id="progressBar" value="0" max="100"></progress>
                        <span id="progressText">0%</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>


    // On récupère le canevas
    const canevas_box = document.getElementById('canvasBox');
    var $ = go.GraphObject.make; // Raccourci pour accéder à la bibliothèque GoJS

    // Créartion d'une variable globale la configuration 
    const config = {
        simunlation_started: false,
        layout: "layout",
        mode: "alice_bob",
    }
    // Création d'un proxy pour détecter les changements de la configuration
    const handler = {
        set(obj, prop, newValue) {
            console.log(`La propriété "${prop}" a changé de ${obj[prop]} à ${newValue}`);
            obj[prop] = newValue;
            return true;
        }
    };
    //
    const config_proxy = new Proxy(config, handler);

    // Création du diagramme
    var myDiagram = $(go.Diagram, "myDiagramDiv", {
        "undoManager.isEnabled": true, // Activer le gestionnaire d'annulation
        "panningTool.isEnabled": false, // Désactiver le déplacement du diagramme
        isReadOnly: false, // Permet de cliquer sur les cellules 
        initialAutoScale: go.AutoScale.Uniform
    });

    function addNode(name) {
        /* Ajouter un nœud au diagramme */

        var newNodeKey = name;
        var x = Math.random() * 400;
        var y = Math.random() * 400;
        myDiagram.startTransaction("add node");
        myDiagram.model.addNodeData({ key: newNodeKey, loc: x + " " + y, color: "lightblue" });
        myDiagram.model.addLinkData({ from: "Alice", to: newNodeKey, color: "black" }); // Relier chaque nouveau nœud à A
        myDiagram.commitTransaction("add node");
        // Ajouter le nouveau nœud à la liste des nœuds
        var option = document.createElement("option");
        option.text = newNodeKey;
    }

    function updateNode(nodeKey, color) {
        // Mettre à jour la couleur d'un nœud
        var node = myDiagram.model.findNodeDataForKey(nodeKey);
        if (node) {
            myDiagram.startTransaction("update node");
            myDiagram.model.setDataProperty(node, "color", color || "lightblue");
            myDiagram.commitTransaction("update node");
        } else {
            alert("Nœud introuvable : " + nodeKey);
        }
    }

    function updateNodes(nodeKeys, color) {
        // Mettre à jour la couleur de plusieurs nœuds
        myDiagram.startTransaction("update nodes");

        const model = myDiagram.model;
        nodeKeys.forEach(nodeKey => {
            const node = model.findNodeDataForKey(nodeKey);
            if (node) {
                model.setDataProperty(node, "color", color || "lightblue");
            } else {
                console.warn("Nœud introuvable : " + nodeKey);
            }
        });

        myDiagram.commitTransaction("update nodes");
    }

    function deleteNode(nodeKey) {
        // Supprimer un nœud
        var node = myDiagram.model.findNodeDataForKey(nodeKey);
        if (node) {
            myDiagram.startTransaction("delete node");
            myDiagram.model.removeNodeData(node);
            myDiagram.commitTransaction("delete node");
        } else {
            alert("Nœud introuvable");
        }
    }

    function findLink(fromNodeKey, toNodeKey) {
        // Rechercher un lien entre deux nœuds
        return myDiagram.model.linkDataArray.find(link =>
            (link.from === fromNodeKey && link.to === toNodeKey) ||
            (link.from === toNodeKey && link.to === fromNodeKey));
    }

    function getNodeLinks(nodeKey) {
        // Récupérer les liens d'un nœud
        return myDiagram.model.linkDataArray.filter(link => link.from === nodeKey || link.to === nodeKey);
    }

    function deleteLink(fromNodeKey, toNodeKey) {
        // Supprimer un lien
        var link = findLink(fromNodeKey, toNodeKey);
        if (link) {
            myDiagram.startTransaction("delete link");
            myDiagram.model.removeLinkData(link);
            myDiagram.commitTransaction("delete link");
        } else {
            alert("Lien introuvable");
        }
    }

    function nodeClicked(e, node) {
        // handler pour le click sur un node
        // alert(config_proxy.layout);
        const list_color = ['lightblue', 'green', 'red', 'yellow', 'black', 'white'];
        // prend la couleur suivante
        let color = list_color[(list_color.indexOf(node.data.color) + 1) % list_color.length];
        myDiagram.model.setDataProperty(node.data, "color", color);

        // if (layout === "custom") {
            // const color = node.data.color === "white" ? "black" : "white";
            // myDiagram.model.setDataProperty(node.data, "color", color);
        // }


    }


    function updateLink(fromNodeKey, toNodeKey, color) {
        // Mettre à jour la couleur d'un lien
        var link = findLink(fromNodeKey, toNodeKey);
        if (link) {
            myDiagram.startTransaction("update link");
            myDiagram.model.setDataProperty(link, "color", color || "red");
            myDiagram.commitTransaction("update link");
        } else {
            alert("Lien introuvable");
        }
    }

    function linkClicked(e, link) {
        // handler pour le click sur un lien

    }

    /* ALICE BOB */

    function alice_bob() {
        // Change le mode pour la simulation Alice-Bob

        // change le layout
        config_proxy.Layout = "force";
        changeLayout();

        // Création du diagramme
        myDiagram.nodeTemplate =
            $(go.Node, "Auto",
                { locationSpot: go.Spot.Center, click: nodeClicked },
                new go.Binding("location", "loc", go.Point.parse).makeTwoWay(go.Point.stringify),
                $(go.Shape, "RoundedRectangle",
                    { fill: "lightblue" },
                    new go.Binding("fill", "color")),
                $(go.TextBlock,
                    { margin: 8 },
                    new go.Binding("text", "key"))
            );
        // Création du lien
        myDiagram.linkTemplate =
            $(go.Link,
                { corner: 5, click: linkClicked },
                $(go.Shape, new go.Binding("stroke", "color"))
            );

        // Création des nœuds
        myDiagram.model = new go.GraphLinksModel(
            [
                { key: "Alice", loc: "0 0", color: "lightblue" },
                { key: "Bob", loc: "100 0", color: "lightblue" }
            ],
            [
                { from: "Alice", to: "Bob", color: "black" }
            ]
        );

    }

    async function simulate_alice_bob() {
        // Simuler la communication entre Alice et Bob

        var btn = document.getElementById('alice_bob_btn');
        if (config_proxy.simunlation_started) {
            btn.classList.remove('btn-danger');
            btn.classList.add('btn-success');
            btn.innerHTML = 'Start';
            config_proxy.simunlation_started = false;
            return;
        }

        btn.classList.remove('btn-success');
        btn.classList.add('btn-danger');
        btn.innerHTML = 'Stop';
        let p_alice = parseFloat(document.getElementById('ratio_alice').value);
        let p_bob = parseFloat(document.getElementById('ratio_bob').value);
        let message_length = parseInt(document.getElementById('message_length').value);
        let disconnect_percentage = parseInt(document.getElementById('disconnect_percentage').value);


        config_proxy.simunlation_started = true;
        await fetch_alice_bob(p_alice, p_bob, message_length, disconnect_percentage);
    }

    async function fetch_alice_bob(p_alice = 0.2, p_bob = 0.5, message_length = 10, disconnect_percentage = 2, message = '') {
        // Récupérer les données de la simulation Alice-Bob en streaming

        const response = await fetch(`/AliceBob/?p_alice=${p_alice}&p_bob=${p_bob}&message_length=${message_length}&disconnect_percentage=${disconnect_percentage}&message=${message}`);
        let console_alice_bob_alice = document.getElementById('console_alice_bob_alice');
        let width_console_alice = console_alice_bob_alice.clientWidth;
        let case_width_alice = (width_console_alice / 4) - 3;
        console_alice_bob_alice.style.wordSpacing = case_width_alice + 'px';

        const len_steps = message_length.toString().length;

        if (!response.ok) {
            console.error("Erreur:", response.statusText);
            return;
        }

        const reader = response.body.getReader();
        const decoder = new TextDecoder('utf-8');
        console_alice_bob_alice.value = '';
        updateNode('Bob', 'lightblue');


        while (config_proxy.simunlation_started) {
            const { done, value } = await reader.read();
            if (done) {
                simulate_alice_bob();
                break;
            }
            const chunk = decoder.decode(value, { stream: true });
            const lines = chunk.split('\n');

            for (const line of lines) {
                if (line.trim() === '') continue; // Ignorer les lignes vides

                try {
                    // Parser la ligne en tant qu'objet JSON
                    const data = JSON.parse(line);
                    console.log(data); // Afficher dans la console

                    if (data.step) {
                        let zero_before = '0'.repeat(len_steps - data.step.toString().length);
                        let alice_line = [`${zero_before}${data.step}`, data.alice, data.bob, data.guess];
                        console_alice_bob_alice.value += alice_line.join(' ') + '\n';
                        // scroll J'usqu'à la fin
                        console_alice_bob_alice.scrollTop = console_alice_bob_alice.scrollHeight;
                        // change Node color to red if data.disconneted is true
                        if (data.disconnected) {
                            updateNode('Bob', 'red');
                        }
                    }

                    if (data.accuracy) {

                    }



                } catch (error) {
                    console.error('Erreur de parsing JSON :', error, line);
                }
            }


        }
        config_proxy.simunlation_started = false;
    }

    /*  MNIST */

    function alice_mnist() {
        // Change le mode pour la simulation Alice-MNIST

        // remove diagram layout CircularLayout Sample
        config_proxy.Layout = "layout";
        changeLayout();
        const rows = 28, cols = 28; // Taille de la grille
        const nodeSize = 100; // Taille d'une cellule

        myDiagram.nodeTemplate = $(
            go.Node,
            "Auto",
            { locationSpot: go.Spot.Center },
            $(
                go.Shape,
                "Rectangle",
                {
                    fill: "white", // Couleur par défaut
                    stroke: "#A2A2A2", // Couleur de la bordure
                    strokeWidth: 1,
                    width: nodeSize,
                    height: nodeSize
                },
                new go.Binding("fill", "color") // Lie la couleur à la propriété "color"
            ),

        );

        // Création de la grille
        const nodeDataArray = [];
        for (let i = 0; i < rows; i++) {
            for (let j = 0; j < cols; j++) {
                nodeDataArray.push({
                    key: `${i}-${j}`, // Identifiant unique
                    loc: new go.Point(j * nodeSize, i * nodeSize), // Position dans la grille
                    color: "green" // Couleur initiale
                });
            }
        }

        // Appliquer le modèle
        myDiagram.model = new go.GraphLinksModel({ nodeDataArray });
    }

    function simulate_alice_mnist() {
        // Simuler la reconstruction d'une image MNIST
        let drop_probability = document.getElementById('drop_probability').value;
        let num_samples = document.getElementById('num_samples').value;
        fetch_alice_mnist(drop_probability, num_samples);
    }

    async function fetch_alice_mnist(drop_probability = 0.6, num_samples = 10) {
        // Récupérer les données de la simulation MNIST en streaming
        const canvas = document.createElement('canvas');
        canvas.width = 28; // Largeur du canvas
        canvas.height = 28; // Hauteur du canvas
        const ctx = canvas.getContext('2d');
        const response = await fetch(`/AliceMnist/?drop_probability=${drop_probability}&num_samples=${num_samples}`);
        if (!response.ok) {
            console.error("Erreur:", response.statusText);
            return;
        }

        const reader = response.body.getReader();
        const decoder = new TextDecoder('utf-8');

        while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            const chunk = decoder.decode(value, { stream: true });
            const lines = chunk.split('\n');

            for (const line of lines) {
                if (line.trim() === '') continue; // Ignorer les lignes vides

                try {
                    // Parser la ligne en tant qu'objet JSON
                    if (line.trim().startsWith('{') && line.trim().endsWith('}')) {
                        const data = JSON.parse(line);
                        console.log(data); // Afficher dans la console
                        // Afficher dans l'interface utilisateur
                        // document.getElementById('output').innerHTML += `<p>${data.message}</p>`;



                        /* Gestion des noeuds desactivés et de l'image correspondante */

                        // Récupérer les noeuds désactivés et les colories en rouge
                        let droped_nodes = [];
                        for (let i = 0; i < data.dropped.length; i++) {
                            for (let j = 0; j < data.dropped[i].length; j++) {
                                let key = `${i}-${j}`;
                                if (data.dropped[i][j] === -1) {
                                    // updateNode(key, 'red');
                                    droped_nodes.push(key);
                                }
                            }

                        }
                        let all_nodes = myDiagram.model.nodeDataArray.map(node => node.key);
                        updateNodes(all_nodes, 'green');
                        updateNodes(droped_nodes, 'red');

                        // Afficher l'image dropée
                        const imgDropped = document.getElementById('img-dropped');
                        const imgData = ctx.createImageData(28, 28);

                        for (let i = 0; i < 28; i++) {
                            for (let j = 0; j < 28; j++) {
                                const index = (i * 28 + j) * 4;
                                if (data.dropped[i][j] === -1) {
                                    imgData.data[index] = 255;
                                    imgData.data[index + 1] = 0;
                                    imgData.data[index + 2] = 0;
                                    imgData.data[index + 3] = 255;
                                } else {
                                    const value = data.dropped[i][j] > 0.5 ? 255 : 0;
                                    imgData.data[index] = value;
                                    imgData.data[index + 1] = value;
                                    imgData.data[index + 2] = value;
                                    imgData.data[index + 3] = 255;
                                }

                            }
                        }

                        ctx.putImageData(imgData, 0, 0);
                        imgDropped.style.backgroundImage = `url(${canvas.toDataURL()})`;

                        // Afficher l'image originale
                        const imgOriginal = document.getElementById('img-original');
                        const imgDataOriginal = ctx.createImageData(28, 28);

                        for (let i = 0; i < 28; i++) {
                            for (let j = 0; j < 28; j++) {
                                const index = (i * 28 + j) * 4;
                                const value = data.original[i][j] > 0.5 ? 255 : 0;
                                imgDataOriginal.data[index] = value;
                                imgDataOriginal.data[index + 1] = value;
                                imgDataOriginal.data[index + 2] = value;
                                imgDataOriginal.data[index + 3] = 255;
                            }
                        }

                        ctx.putImageData(imgDataOriginal, 0, 0);
                        imgOriginal.style.backgroundImage = `url(${canvas.toDataURL()})`;


                        // Afficher l'image reconstituée
                        const imgReconstructed = document.getElementById('img-reconstructed');
                        const imgDataReconstructed = ctx.createImageData(28, 28);

                        for (let i = 0; i < 28; i++) {
                            for (let j = 0; j < 28; j++) {
                                const index = (i * 28 + j) * 4;
                                const value = data.reconstructed[i][j] * 255;
                                imgDataReconstructed.data[index] = value;
                                imgDataReconstructed.data[index + 1] = value;
                                imgDataReconstructed.data[index + 2] = value;
                                imgDataReconstructed.data[index + 3] = 255;
                            }

                        }


                        ctx.putImageData(imgDataReconstructed, 0, 0);
                        imgReconstructed.style.backgroundImage = `url(${canvas.toDataURL()})`;



                    } else {
                        console.log(line);
                    }
                } catch (error) {
                    console.error('Erreur de parsing JSON :', error, line);
                }
            }

            // Afficher dans une div HTML
            // document.getElementById("output").innerText += chunk;
        }
    }


    /* MIS */
    function mis() {
        config_proxy.Layout = "force";
        changeLayout();

        const vertices = document.getElementById('nb_nodes').value;

        myDiagram.nodeTemplate =
            $(go.Node, "Auto",
                { locationSpot: go.Spot.Center, click: nodeClicked },
                new go.Binding("location", "loc", go.Point.parse).makeTwoWay(go.Point.stringify),
                $(go.Shape, "RoundedRectangle",
                    { fill: "lightblue" },
                    new go.Binding("fill", "color")),
                $(go.TextBlock,
                    { margin: 8 },
                    new go.Binding("text", "key"))
            );

        myDiagram.linkTemplate =
            $(go.Link,
                { corner: 5, click: linkClicked },
                $(go.Shape, new go.Binding("stroke", "color"))
            );

        const myDiagramModel = generateGraph("eulerien", vertices, {
            vertexColor: "lightblue",
            edgeColor: "gray"
        });

        // Assigner le modèle au diagramme
        myDiagram.model = myDiagramModel;
    }

    function findMIS(graphModel, nodes, edges) {


        const mis = new Set(); // Ensemble pour stocker le MIS

        // Créer une map pour stocker les voisins de chaque nœud
        const neighbors = new Map();
        for (const node of nodes) {
            neighbors.set(node.key, new Set());
            // console.log(node.p_one);

        }
        // on ajoute les voisins de chaque noeud
        for (const edge of edges) {
            neighbors[0].
                neighbors.get(edge.to).add(edge.from);
        }

        // Fonction pour vérifier si un nœud peut rejoindre le MIS
        function canJoinMIS(nodeKey) {
            for (const neighbor of neighbors.get(nodeKey)) {
                if (mis.has(neighbor)) {
                    return false; // Un voisin est déjà dans le MIS
                }
            }
            return true;
        }

        // Simulation des tours
        let remainingNodes = new Set(nodes.map(node => node.key)); // Nœuds restants

        start_node_with_most_neighbors = document.getElementById('start_node_with_most_neighbors').checked;

        if (start_node_with_most_neighbors) {
            let max_neighbors = 0;
            let start_node = '';
            for (const nodeKey of remainingNodes) {
                if (neighbors.get(nodeKey).size > max_neighbors) {
                    max_neighbors = neighbors.get(nodeKey).size;
                    start_node = nodeKey;
                }
            }
            mis.add(start_node);
            remainingNodes.delete(start_node);
            for (const neighbor of neighbors.get(start_node)) {
                remainingNodes.delete(neighbor);
            }
        }
        let cpt = 0;
        while (remainingNodes.size > 0) {

            // Chaque nœud envoie aléatoirement 0 ou 1
            const messages = new Map();
            for (const nodeKey of remainingNodes) {
                node = nodes.find(node => node.key === nodeKey);
                messages.set(nodeKey, Math.random() < node.p_one ? 0 : 1); // 0 ou 1 aléatoire
            }

            // Vérifier les nœuds qui peuvent rejoindre le MIS
            for (const nodeKey of remainingNodes) {
                if (messages.get(nodeKey) === 1) {
                    let allNeighborsSendZero = true;
                    for (const neighbor of neighbors.get(nodeKey)) {
                        if (messages.get(neighbor) === 1) {
                            allNeighborsSendZero = false;
                            break;
                        }
                    }
                    if (allNeighborsSendZero && canJoinMIS(nodeKey)) {
                        mis.add(nodeKey); // Ajouter au MIS
                    }
                }
            }

            // Mettre à jour les nœuds restants
            for (const nodeKey of mis) {
                remainingNodes.delete(nodeKey); // Retirer les nœuds du MIS
                for (const neighbor of neighbors.get(nodeKey)) {
                    remainingNodes.delete(neighbor); // Retirer les voisins
                }
            }
            cpt++;

        }
        document.getElementById('tours_mis').innerText = cpt;
        document.getElementById('mis_size').innerText = mis.size;

        return Array.from(mis); // Retourner le MIS sous forme de tableau
    }

    async function simulate_mis_once() {


        const all_nodes = myDiagram.model.nodeDataArray.map(node => node.key);
        updateNodes(all_nodes, 'lightblue');

        const nodes = myDiagram.model.nodeDataArray; // Liste des nœuds
        const edges = myDiagram.model.linkDataArray; // Liste des arêtes
        let connextions = [];

        for (const edge of edges) {
            let e = [parseInt(edge.from.split('-')[1]), parseInt(edge.to.split('-')[1])];
            let re = [parseInt(edge.to.split('-')[1]), parseInt(edge.from.split('-')[1])];

            if (e in connextions || re in connextions) {
                continue;
            }

            connextions.push(e);
        }



        const reponse = await fetch('/mis/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ nodes, edges, connextions, nb_nodes: nodes.length })
        });
        console.log(reponse);
        if (!reponse.ok) {
            console.error("Erreur:", reponse.statusText);
            return;
        }

        const reader = reponse.body.getReader();
        const decoder = new TextDecoder('utf-8');
        cpt = 0;

        while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            const chunk = decoder.decode(value, { stream: true });
            const lines = chunk.split('\n');

            for (const line of lines) {
                if (line.trim() === '') continue; // Ignorer les lignes vides

                try {
                    // Parser la ligne en tant qu'objet JSON
                    if (line.trim().startsWith('{') && line.trim().endsWith('}')) {
                        const data = JSON.parse(line);
                        console.log(data); // Afficher dans la console
                        // Afficher dans l'interface utilisateur
                        // document.getElementById('output').innerHTML += `<p>${data.message}</p>`;



                        for (let i = 0; i < data.mis.length; i++) {
                            let bob = "Node-" + data.mis[i];
                            updateNode(bob, 'red');
                        }
                        // for(const [i, v] of Object.entries(data.remaining_nodes)){
                        //     const id = "Node-" + v;
                        //     if (v === 1){
                        //         updateNode(id, 'white');
                        //     }
                        //     else{
                        //         updateNode(id, 'black');
                        //     }
                        // }


                        console.log(data); // Afficher dans la console
                        // Afficher dans l'interface utilisateur
                        // document.getElementById('output').innerHTML += `<p>${data.message}</p>`;
                    } else {
                        console.log(line);
                    }
                } catch (error) {
                    console.error('Erreur de parsing JSON :', error, line);
                }
            }

            // Afficher dans une div HTML
            // document.getElementById("output").innerText += chunk;

        }

        // const mis = findMIS(myDiagram.model, nodes, edges);
        // console.log("Maximal Independent Set (MIS):", mis);

        // Mettre en évidence les nœuds du MIS dans le diagramme
        updateNodes(mis, 'green');
        myDiagram.updateAllTargetBindings(); // Mettre à jour l'affichage

    }

    function simsimulate_mis() {

        const all_nodes = myDiagram.model.nodeDataArray.map(node => node.key);
        updateNodes(all_nodes, 'lightblue');

        const nodes = graphModel.nodeDataArray; // Liste des nœuds
        const edges = graphModel.linkDataArray; // Liste des arêtes

        const mis = findMIS(myDiagram.model, nodes, edges);
        // console.log("Maximal Independent Set (MIS):", mis);

        // Mettre en évidence les nœuds du MIS dans le diagramme
        updateNodes(mis, 'green');
        myDiagram.updateAllTargetBindings(); // Mettre à jour l'affichage
    }

    function mis_graph_coloration() {
        // coloration de graphe avec l'algorithme mis 
        let nb_colors = 0;
        let mis = findMIS(myDiagram.model);
        let nodes = myDiagram.model.nodeDataArray;
        let edges = myDiagram.model.linkDataArray;
        let colors = new Map();
        let neighbors = new Map();
        for (const node of nodes) {
            neighbors.set(node.key, new Set());
        }

        for (const edge of edges) {
            neighbors.get(edge.from).add(edge.to);
            neighbors.get(edge.to).add(edge.from);
        }

        for (const node of nodes) {
            colors.set(node.key, 0);
        }

        for (const node of mis) {
            colors.set(node, 1);
        }

        for (const node of nodes) {
            if (colors.get(node.key) === 0) {
                let available_colors = new Set();
                for (const neighbor of neighbors.get(node.key)) {
                    if (colors.get(neighbor) > 0) {
                        available_colors.add(colors.get(neighbor));
                    }
                }
                let color = 1;
                while (available_colors.has(color)) {
                    color++;
                }
                colors.set(node.key, color);
                nb_colors = Math.max(nb_colors, color);
            }
        }

        for (const node of nodes) {
            updateNode(node.key, colors.get(node.key) === 0 ? 'lightblue' : `hsl(${360 * colors.get(node.key) / nb_colors}, 100%, 50%)`);
        }

        document.getElementById('mis_coloration').innerText = nb_colors;





    }


    /* ALICE N BOB */
    function alice_n_bob() {

        const vertices = document.getElementById('nb_nodes').value;

        config_proxy.Layout = "force";
        myDiagram.nodeTemplate =
            $(go.Node, "Auto",
                { locationSpot: go.Spot.Center, click: nodeClicked },

                new go.Binding("location", "loc", go.Point.parse).makeTwoWay(go.Point.stringify),
                $(go.Shape, "RoundedRectangle",
                    { fill: "lightblue" },
                    new go.Binding("fill", "color")),
                $(go.TextBlock,
                    { margin: 8 },
                    new go.Binding("text", "key"))
            );

        myDiagram.linkTemplate =
            $(go.Link,
                { corner: 5, click: linkClicked },
                $(go.Shape, new go.Binding("stroke", "color"))
            );



        const myDiagramModel = generateGraph("alice_n_bob", vertices, {
            vertexColor: "lightblue",
            edgeColor: "gray"
        });

        myDiagram.model = myDiagramModel;


        return true;
    }

    async function simulate_alice_n_bob() {
        // const ok = alice_n_bob();
        // console.log({ ok });
        // if (ok) {
        // }
        var btn = document.getElementById('alice_n_bob_btn');

        if (config_proxy.simunlation_started) {
            btn.classList.remove('btn-danger');
            btn.classList.add('btn-success');
            btn.innerHTML = 'Start';
            config_proxy.simunlation_started = false;
            return;
        }
        btn.classList.remove('btn-success');
        btn.classList.add('btn-danger');
        btn.innerHTML = 'Stop';
        config_proxy.simunlation_started = true;
        await fetch_alice_n_bob();


    }

    async function fetch_alice_n_bob() {

        const nb_bob = document.getElementById('nb_nodes').value;
        const p_alice = document.getElementById('ratio_alice_n').value;
        const p_bob = document.getElementById('ratio_bob_n').value;
        const message_length = document.getElementById('message_length_n').value;
        const disconnect_percentage = document.getElementById('disconnect_percentage_n').value;
        const response = await fetch(`/AliceNBob/?nb_bob=${nb_bob}&p_alice=${p_alice}&p_bob=${p_bob}&message_length=${message_length}&disconnect_percentage=${disconnect_percentage}`);


        // const response = await fetch("/AliceNBob/");

        if (!response.ok) {
            console.error("Erreur:", response.statusText);
            return;
        }

        const reader = response.body.getReader();
        const decoder = new TextDecoder('utf-8');

        while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            const chunk = decoder.decode(value, { stream: true });
            const lines = chunk.split('\n');

            for (const line of lines) {
                if (line.trim() === '') continue; // Ignorer les lignes vides

                try {
                    // Parser la ligne en tant qu'objet JSON
                    if (line.trim().startsWith('{') && line.trim().endsWith('}')) {
                        // const data = JSON.parse(line.slice(5));
                        const data = JSON.parse(line);
                        let disconnecteds = data.disconnecteds;

                        for (let i = 0; i < disconnecteds.length; i++) {
                            let bob = "Bob-" + disconnecteds[i];
                            updateNode(bob, 'red');
                        }



                        console.log(data); // Afficher dans la console
                        // Afficher dans l'interface utilisateur
                        // document.getElementById('output').innerHTML += `<p>${data.message}</p>`;


                    } else {

                        console.log(line);

                    }

                    // const data = JSON.parse(line);
                    // console.log(data); // Afficher dans la console
                    // // Afficher dans l'interface utilisateur
                    // // document.getElementById('output').innerHTML += `<p>${data.message}</p>`;
                    // console.log(data);
                } catch (error) {
                    console.error('Erreur de parsing JSON :', error, line);
                }
            }

            // Afficher dans une div HTML
            // document.getElementById("output").innerText += chunk;
        }
    }


    /*  Mode de simulation */

    function toggle_blur_ovelay(show = false) {
        var botton_option = document.getElementById('botton_option');
        var blur_box = document.getElementById('blur_box');
        if (show) {
            botton_option.classList.add('overlay');
            blur_box.classList.add('blurred-background');
            blur_box.classList.remove('d-none');
        } else {
            botton_option.classList.remove('overlay');
            blur_box.classList.remove('blurred-background');
            blur_box.classList.add('d-none');
        }


    }

    function _changeMode() {
        var e = document.getElementById("mode-select");
        config_proxy.mode = e.options[e.selectedIndex].value;
        changeMode();
    }

    function changeMode() {

        var e = document.getElementById("mode-select");
        var title = document.getElementById('Titre');
        // allowMove: false,

        toggle_blur_ovelay(false);

        // enable select graph type
        var graph_type = document.getElementById('graph_type');
        graph_type.disabled = false;

        // get all box_options and  add class h-0
        var box_options = document.getElementsByClassName('box_options');
        // remove all box_options
        for (var i = 0; i < box_options.length; i++) {
            box_options[i].classList.remove('d-flex');
            box_options[i].classList.add('d-none');
        }

        myDiagram.allowMove = true;

        config_proxy.simunlation_started = false;

        if (config_proxy.mode == 'alice_bob') {
            alice_bob();
            title.innerHTML = 'Alice-Bob';
            // get box 
            var box_alice_bob = document.getElementById('box_alice_bob');
            box_alice_bob.classList.remove('d-none');
            box_alice_bob.classList.add('d-flex');

            toggle_blur_ovelay(true);


        }
        else if (config_proxy.mode == 'alice_n_bob') {
            document.getElementById('nb_nodes').value = 10;
            alice_n_bob();
            title.innerHTML = 'Alice-N-Bob';
            let box = document.getElementById('box_alice_n_bob');
            box.classList.remove('d-none');
            box.classList.add('d-flex');
            graph_type.disabled = true;

        }
        else if (config_proxy.mode == 'alice_mnist') {
            // alice_n_bob(784);
            alice_mnist();
            // desactiver les deplacements des Nodes 
            myDiagram.allowMove = false;
            title.innerHTML = 'Alice-NNIST';
            let box = document.getElementById('box_Mnist');
            box.classList.remove('d-none');
            box.classList.add('d-flex');

            toggle_blur_ovelay(true);
        }
        else if (config_proxy.mode == 'mis') {
            // bob_alice();
            // redraw();

            title.innerHTML = 'MIS';
            let box = document.getElementById('box_mis');
            box.classList.remove('d-none');
            box.classList.add('d-flex');
            document.getElementById('nb_nodes').value = 10;
            mis();
        }
        var e = document.getElementById("mode-select");
        e.value = config_proxy.mode;

    }




    /*  graph */

    function _generateGraph() {
        const vertices = document.getElementById('nb_nodes').value;
        const type = document.getElementById('graph_type').value;

        const myDiagramModel = generateGraph(type, vertices, {});
        myDiagram.model = myDiagramModel;
    }

    function generateGraph(type, numVertices, options = {}) {

        const vertices = [];
        const edges = [];

        type = (config_proxy.mode == 'alice_n_bob') ? 'Alice_n_bob' : type;

        let Name = "Node"
        if (type === "Alice_n_bob") {
            Name = "Bob";
        } else {
            document.getElementById('graph_type').value = type;
        }


        // Générer les sommets
        for (let i = 0; i < numVertices; i++) {
            const vertex = {
                key: `${Name}-${i + 1}`, // Clé unique pour chaque sommet
                // loc: `${i * 100} 0`, // Position (x y) du sommet (peut être ignorée si un layout est utilisé)
                color: options.vertexColor || "lightblue", // Couleur du sommet
                p_one: Math.random(),
                id: i + 1

            };
            vertices.push(vertex);
        }

        // Générer les arêtes en fonction du type de graphe
        if (type === "complete") {
            // Graphe complet : chaque sommet est relié à tous les autres
            for (let i = 0; i < numVertices; i++) {
                for (let j = i + 1; j < numVertices; j++) {
                    edges.push({
                        from: vertices[i].key,
                        to: vertices[j].key,
                        color: options.edgeColor || "black"
                    });
                }
            }
        }
        else if (type === "cycle") {
            // Graphe cyclique : chaque sommet est relié à son voisin
            for (let i = 0; i < numVertices; i++) {
                const next = (i + 1) % numVertices; // Relier le dernier au premier
                edges.push({
                    from: vertices[i].key,
                    to: vertices[next].key,
                    color: options.edgeColor || "black"
                });
            }
        }
        else if (type === "random") {
            // Graphe aléatoire : générer des arêtes aléatoirement
            const numEdges = options.numEdges || Math.floor(numVertices * 1.5); // Nombre d'arêtes par défaut
            for (let i = 0; i < numEdges; i++) {
                const from = Math.floor(Math.random() * numVertices);
                const to = Math.floor(Math.random() * numVertices);
                if (from !== to) { // Éviter les boucles
                    edges.push({
                        from: vertices[from].key,
                        to: vertices[to].key,
                        color: options.edgeColor || "black"
                    });
                }
            }
        }
        else if (type === "tree") {
            // Arbre : chaque sommet est connecté à un parent (sauf la racine)
            for (let i = 1; i < numVertices; i++) {
                const parent = Math.floor(Math.random() * i); // Choisir un parent aléatoire parmi les sommets précédents
                edges.push({
                    from: vertices[parent].key,
                    to: vertices[i].key,
                    color: options.edgeColor || "black"
                });
            }
        }
        else if (type === "bipartite") {
            // Biparti : diviser les sommets en deux ensembles et connecter entre eux
            const set1 = Math.floor(numVertices / 2);
            for (let i = 0; i < set1; i++) {
                for (let j = set1; j < numVertices; j++) {
                    edges.push({
                        from: vertices[i].key,
                        to: vertices[j].key,
                        color: options.edgeColor || "black"
                    });
                }
            }
        }
        else if (type === "grid") {
            // Grille : disposer les sommets en grille et connecter les voisins
            const rows = Math.floor(Math.sqrt(numVertices));
            const cols = Math.ceil(numVertices / rows);
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    const index = i * cols + j;
                    if (index >= numVertices) break;
                    if (j < cols - 1 && index + 1 < numVertices) { // Connecter à droite
                        edges.push({
                            from: vertices[index].key,
                            to: vertices[index + 1].key,
                            color: options.edgeColor || "black"
                        });
                    }
                    if (i < rows - 1 && index + cols < numVertices) { // Connecter en bas
                        edges.push({
                            from: vertices[index].key,
                            to: vertices[index + cols].key,
                            color: options.edgeColor || "black"
                        });
                    }
                }
            }
        }
        else if (type === "star") {
            // Étoile : un sommet central connecté à tous les autres
            const center = 0; // Le premier sommet est le centre
            for (let i = 1; i < numVertices; i++) {
                edges.push({
                    from: vertices[center].key,
                    to: vertices[i].key,
                    color: options.edgeColor || "black"
                });
            }
        }
        else if (type === "path") {
            // Linéaire : les sommets sont connectés en ligne
            for (let i = 0; i < numVertices - 1; i++) {
                edges.push({
                    from: vertices[i].key,
                    to: vertices[i + 1].key,
                    color: options.edgeColor || "black"
                });
            }
        }
        else if (type === "custom") {
            // Graphe personnalisé : à implémenter

        }
        else if (type === "regular") {
            //Graphe régulier 
            const degree = options.degree || 2;
            for (let i = 0; i < numVertices; i++) {
                for (let j = 1; j <= degree; j++) {
                    const to = (i + j) % numVertices;
                    edges.push({
                        from: vertices[i].key,
                        to: vertices[to].key,
                        color: options.edgeColor || "black"
                    });
                }
            }
        }
        else if (type === "planaire") {
            //Graphe planaire
            const degree = options.degree || 2;
            for (let i = 0; i < numVertices; i++) {
                for (let j = 1; j <= degree; j++) {
                    const to = (i + j) % numVertices;
                    edges.push({
                        from: vertices[i].key,
                        to: vertices[to].key,
                        color: options.edgeColor || "black"
                    });
                }
            }
        }
        else if (type === "eulerien") {
            //Graphe eulerien
            const degree = options.degree || 2;
            for (let i = 0; i < numVertices; i++) {
                for (let j = 1; j <= degree; j++) {
                    const to = (i + j) % numVertices;
                    edges.push({
                        from: vertices[i].key,
                        to: vertices[to].key,
                        color: options.edgeColor || "black"
                    });
                }
            }

        }
        else if (type === "hamiltonien") {
            //Graphe hamiltonien
            const degree = options.degree || 2;
            for (let i = 0; i < numVertices; i++) {
                for (let j = 1; j <= degree; j++) {
                    const to = (i + j) % numVertices;
                    edges.push({
                        from: vertices[i].key,
                        to: vertices[to].key,
                        color: options.edgeColor || "black"
                    });
                }
            }

        }
        else if (type = "Alice_n_bob") {
            // create Alice 
            vertices.push({
                key: "Alice", // Clé unique pour chaque sommet
                loc: `0 0`, // Position (x y) du sommet (peut être ignorée si un layout est utilisé)
                color: options.vertexColor || "lightblue" // Couleur du sommet
            });
            for (let i = 0; i < numVertices; i++) {
                edges.push({
                    from: "Alice",
                    to: `${Name}-${i + 1}`,
                    color: options.edgeColor || "black"
                });
            }

        }
        else {
            throw new Error("Type de graphe non supporté. Choisissez entre 'complete', 'cycle', 'random', 'tree', 'bipartite', 'grid', 'star', 'path', 'custom', 'regular', 'planaire', 'eulerien', 'hamiltonien'");
        }

        // Créer le modèle GraphLinksModel
        const model = new go.GraphLinksModel(vertices, edges);

        // Assigner le layout idéal en fonction du type de graphe

        if (type === "complete" || type === "cycle" || type === "star") {
            config_proxy.Layout = "circular";
        } else if (type === "random") {
            config_proxy.Layout = "force";
        } else if (type === "tree") {
            config_proxy.Layout = "tree";
        } else if (type === "bipartite") {
            config_proxy.Layout = "layered";
        } else if (type === "grid") {
            config_proxy.Layout = "grid";
        } else if (type === "path") {
            config_proxy.Layout = "layered";
        }
        else if (type === "regular") {
            config_proxy.Layout = "force";
        }
        else if (type === "planaire") {
            config_proxy.Layout = "force";
        }
        else if (type === "eulerien") {
            config_proxy.Layout = "force";
        }
        else if (type === "hamiltonien") {
            config_proxy.Layout = "force";
        }
        else if (type === "Alice_n_bob") {
            config_proxy.Layout = "force";
        }
        else {
            config_proxy.Layout = "force";
        }

        // Assigner le layout au diagramme
        if (config_proxy.Layout) {
            changeLayout();
        }



        return model;
    }


    function _changeLayout() {
        const e = document.getElementById("layout");
        config_proxy.Layout = e.options[e.selectedIndex].value;
        changeLayout();

    }

    function changeLayout() {

        if (config_proxy.Layout == 'force') {
            myDiagram.layout = $(go.ForceDirectedLayout); // pour les graphes aléatoires
        }
        else if (config_proxy.Layout == 'circular') {
            myDiagram.layout = $(go.CircularLayout); // pour les graphes complets, cycliques et étoiles
        }
        else if (config_proxy.Layout == 'layered') {
            myDiagram.layout = $(go.LayeredDigraphLayout); // pour les graphes bipartis et linéaires
        }
        else if (config_proxy.Layout == 'grid') {
            myDiagram.layout = $(go.GridLayout); // pour les grilles
        }
        else if (config_proxy.Layout == 'tree') {
            myDiagram.layout = $(go.TreeLayout); // pour les arbres
        }
        else if (config_proxy.Layout == 'layout') {
            myDiagram.layout = $(go.Layout); // pour les graphes aléatoires
        }
        else {
            myDiagram.layout = $(go.ForceDirectedLayout); // pour les graphes aléatoires
        }
        const e = document.getElementById("layout");
        e.value = config_proxy.Layout;
        myDiagram.updateAllTargetBindings();

    }

    (() => {

        changeMode();
    })();




</script>
{% endblock %}